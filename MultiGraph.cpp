#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>




//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    return  (1-alpha) * w0 + alpha * w1;
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    /* TODO */
    
    for(int i=0;i<(int)vertexList.size();i++){
        if(vertexList[i].name == vertexName){
            throw DuplicateVertexException(vertexName);
        }
    }
    GraphVertex newvertex;
    newvertex.name=vertexName;
    vertexList.push_back(newvertex);
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    /* TODO */
    int index=-1;
    for(int i=0;i<(int)vertexList.size();i++){
        if(vertexList[i].name == vertexName){
            index=i;
        }
    }
    if(index==-1){
        throw VertexNotFoundException(vertexName);
    }
    for(int i=0;i<(int)vertexList.size();i++){
        for(int j=0;j<(int)vertexList[i].edges.size();j++){
            if(vertexList[i].edges[j].endVertexIndex==index){
                vertexList[i].edges.erase(vertexList[i].edges.begin()+j);
            }
            if(vertexList[i].edges[j].endVertexIndex>index){
                vertexList[i].edges[j].endVertexIndex--;
            }
        }
    }
    vertexList.erase(vertexList.begin()+index);
    
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
    GraphEdge newEdge;
    newEdge.name = edgeName;
    newEdge.weight[0] = weight0;
    newEdge.weight[1] = weight1;
    
    int indexFrom = -1;
    int indexTo = -1;
    for(int i=0; i<(int)vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName){
            indexFrom = i;
        }
        if(vertexList[i].name == vertexToName){
            indexTo = i;
        }
    }
    if(indexFrom == -1){
        throw VertexNotFoundException(vertexFromName);
    }
    if(indexTo == -1){
        throw VertexNotFoundException(vertexToName);
    }
    for(int i=0; i<(int)vertexList[indexFrom].edges.size(); i++){
        if(edgeName == vertexList[indexFrom].edges[i].name && vertexList[indexFrom].edges[i].endVertexIndex==indexTo){
            throw SameNamedEdgeException(edgeName, vertexFromName, vertexToName);
        }
    }
    
    newEdge.endVertexIndex = indexTo;
    vertexList[indexFrom].edges.push_back(newEdge);

}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    /* TODO */
    int indexFrom = -1;
    int indexTo = -1;
    bool flag = false;
    for(int i=0; i<(int)vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName){
            indexFrom = i;
        }
        if(vertexList[i].name == vertexToName){
            indexTo = i;
        }
    }
    if(indexFrom == -1){
        throw VertexNotFoundException(vertexFromName);
    }
    if(indexTo == -1){
        throw VertexNotFoundException(vertexToName);
    }
    for(int i=0; i<(int)vertexList[indexFrom].edges.size(); i++){
        if(edgeName == vertexList[indexFrom].edges[i].name){
            vertexList[indexFrom].edges.erase(vertexList[indexFrom].edges.begin()+i);
            flag=true;
        }
    }
    if(!flag){
        throw EdgeNotFoundException(vertexFromName, edgeName);
    }
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    
    std::vector<float> dist(vertexList.size(),50000.0);
    Pair<int,int> package;
    package.key=-1;
    package.value=-1;
    std::vector<Pair<int,int>> prev(vertexList.size(), package);
    
    std::vector<bool> visited(vertexList.size(), false);

    int startVertexIndex = -1, endVertexIndex = -1;
    for (int i = 0; i < (int)vertexList.size(); ++i)
    {
        if (vertexList[i].name == vertexNameFrom)
            startVertexIndex = i;
        if (vertexList[i].name == vertexNameTo)
            endVertexIndex = i;
    }

    if (startVertexIndex == -1)
        throw VertexNotFoundException(vertexNameFrom);
    if (endVertexIndex == -1)
        throw VertexNotFoundException(vertexNameTo);

    MinPairHeap<float, int> minHeap;
    Pair<float,int> vertexPair;
    vertexPair.key=0.0f;
    vertexPair.value= startVertexIndex;
    minHeap.push(vertexPair);
 
    dist[startVertexIndex] = 0.0f;
    int u=-1;
    int v = -1;
    float weight = -1.0f;
    while (!minHeap.empty())
    {
        u = minHeap.top().value;
        minHeap.pop();
        visited[u] = true;

        for (int i = 0; i < (int)vertexList[u].edges.size(); ++i)
        {
            v = vertexList[u].edges[i].endVertexIndex;
            weight = Lerp(vertexList[u].edges[i].weight[0], vertexList[u].edges[i].weight[1], heuristicWeight);
            if (!visited[v] and dist[u] + weight < dist[v])
            {
                dist[v] = dist[u] + weight;
                prev[v].key = u;
                prev[v].value = i;  
                vertexPair.key=dist[v];
                vertexPair.value=v;
                minHeap.push(vertexPair);
            }
        }
    }

    if (!visited[endVertexIndex])
        return false;

    int k = endVertexIndex;
    while (k != -1)
    {
        orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(),k);
        if (prev[k].key != -1)
            orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(),prev[k].value);
        k = prev[k].key;
    }
    return true;
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    /* TODO */
    std::vector<float> dist(vertexList.size(), 50000);
    Pair<int,int> package;
    package.key=-1;
    package.value=-1;
    std::vector<Pair<int,int>> prev(vertexList.size(), package);
    
    std::vector<bool> visited(vertexList.size(), false);

    int startVertexIndex = -1, endVertexIndex = -1;
    for (int i = 0; i < (int)vertexList.size(); ++i)
    {
        if (vertexList[i].name == vertexNameFrom)
            startVertexIndex = i;
        if (vertexList[i].name == vertexNameTo)
            endVertexIndex = i;
    }

    if (startVertexIndex == -1)
        throw VertexNotFoundException(vertexNameFrom);
    if (endVertexIndex == -1)
        throw VertexNotFoundException(vertexNameTo);

    MinPairHeap<float, int> minHeap;
    Pair<float,int> vertexPair;
    vertexPair.key=0.0f;
    vertexPair.value= startVertexIndex;
    minHeap.push(vertexPair);
 
    dist[startVertexIndex] = 0.0f;
    bool flag = false;
    while (!minHeap.empty())
    {
        int u = minHeap.top().value;
        minHeap.pop();
        visited[u] = true;
        
        for (int i = 0; i < (int)vertexList[u].edges.size(); ++i)
        {
            flag=false;
            for (int j = 0; j < (int)edgeNames.size(); ++j)
            {
                if (vertexList[u].edges[i].name == edgeNames[j])
                {
                    flag = true;
                    break;
                }
            }
            if (flag)
                continue;

            int v = vertexList[u].edges[i].endVertexIndex;
            float weight = Lerp(vertexList[u].edges[i].weight[0], vertexList[u].edges[i].weight[1], heuristicWeight);
            if (!visited[v] and dist[u] + weight < dist[v])
            {
                dist[v] = dist[u] + weight;
                prev[v].key = u;
                prev[v].value = i; 
                vertexPair.key=dist[v];
                vertexPair.value=v;
                minHeap.push(vertexPair);
            }
        }
    }

    if (!visited[endVertexIndex])
        return false;

    int k = endVertexIndex;
    while (k != -1)
    {
        orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(),k);
        if (prev[k].key != -1)
            orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(),prev[k].value);
        k = prev[k].key;
    }

    
    return true;
}

int MultiGraph::BiDirectionalEdgeCount() const
{
    int first;
    int count =0;
    for(int i=0; i< (int)vertexList.size();i++){
        for(int j=0; j< (int)vertexList[i].edges.size();j++){
            first=vertexList[i].edges[j].endVertexIndex;
            for(int k=0; k<(int)vertexList[first].edges.size();k++){
                if(vertexList[first].edges[k].endVertexIndex==i && vertexList[first].edges[k].name == vertexList[i].edges[j].name){
                    count++;
                }
            }
        }
    }
    return count/2;
   
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{

    int startVertexIndex = -1;
    for (int i = 0; i < (int)vertexList.size(); ++i)
    {
        if (vertexList[i].name == vertexName)
        {
            startVertexIndex = i;
            break;
        }
    }


    if (startVertexIndex == -1)
        throw VertexNotFoundException(vertexName);


    std::vector<bool> visited(vertexList.size(), false);

    std::vector<int> depth(vertexList.size(), 0);

    
    MinPairHeap<int, int> minHeap;
    Pair<int,int> vertexPair;
    vertexPair.key = 0;
    vertexPair.value = startVertexIndex;
    minHeap.push(vertexPair);

    while (!minHeap.empty())
    {
        Pair<int, int> p = minHeap.top();
        minHeap.pop();

        int u = p.value;
        int currentDepth = p.key;

        if (!visited[u])
        {
            visited[u] = true;
            depth[u] = currentDepth;

            
            for (int i = 0; i < (int)vertexList[u].edges.size(); ++i)
            {
               
                if (vertexList[u].edges[i].name == edgeName)
                {
                    int v = vertexList[u].edges[i].endVertexIndex;

                    
                    vertexPair.key = currentDepth + 1;
                    vertexPair.value = v;
                    minHeap.push(vertexPair);
                }
            }
        }
    }
    
    int max=-1;
    for(int i=0;i<(int)depth.size();i++){
        if(depth[i]>max){
            max=depth[i];
        }
    }
    
    return max;
}

std::vector<GraphVertex>& MultiGraph::getVertexList() { 
    return vertexList; 
}

